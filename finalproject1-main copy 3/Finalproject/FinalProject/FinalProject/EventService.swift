////  EventService.swift//  FinalProject////  Created by Ahmet Aytac on 11/16/25.//////  EventService.swift//  FinalProject////  Created by Enhanced Features//import Foundationimport ParseSwiftimport UIKitimport CoreLocationclass EventService {    static let shared = EventService()        private init() {}            func createEvent(        title: String,        description: String,        eventDate: Date,        endDate: Date?,        location: CLLocationCoordinate2D,        address: String,        category: EventCategory,        image: UIImage?,        clubId: String?,        isPublic: Bool,        requiresApproval: Bool,        maxAttendees: Int?,        tags: [String]    ) async throws -> Event {        guard let userId = User.current?.objectId,              let username = User.current?.username else {            throw NSError(domain: "EventService", code: 401, userInfo: [NSLocalizedDescriptionKey: "User not logged in"])        }                var event = Event()        event.title = title        event.description = description        event.hostId = userId        event.hostUsername = username        event.eventDate = eventDate        event.endDate = endDate        event.location = try ParseGeoPoint(latitude: location.latitude, longitude: location.longitude)        event.address = address        event.category = category.rawValue        event.clubId = clubId        event.isPublic = isPublic        event.requiresApproval = requiresApproval        event.maxAttendees = maxAttendees        event.tags = tags        event.attendeesCount = 0        event.interestedCount = 0                // Upload image if provided        if let image = image, let imageData = image.jpegData(compressionQuality: 0.7) {            let parseFile = ParseFile(name: "event_\(UUID().uuidString).jpg", data: imageData)            let savedFile = try await parseFile.save()            event.imageFile = savedFile            event.imageURL = savedFile.url?.absoluteString        }                // Get club name if associated with club        if let clubId = clubId {            let allClubs = try await Club.query().find()            if let club = allClubs.first(where: { $0.objectId == clubId }) {                event.clubName = club.name            }        }                let savedEvent = try await event.save()        print("✅ Event created: \(savedEvent.objectId ?? "unknown")")                return savedEvent    }            func getAllEvents() async throws -> [Event] {        let query = Event.query()            .order([.ascending("eventDate")])            .limit(100)                let events = try await query.find()                // Filter to only future events        let now = Date()        return events.filter { event in            guard let eventDate = event.eventDate else { return false }            return eventDate > now        }    }        func getUpcomingEvents(limit: Int = 20) async throws -> [Event] {        let allEvents = try await getAllEvents()        return Array(allEvents.prefix(limit))    }        func getEventsByCategory(category: EventCategory) async throws -> [Event] {        let allEvents = try await getAllEvents()        return allEvents.filter { $0.category == category.rawValue }    }        func getEventsByClub(clubId: String) async throws -> [Event] {        let allEvents = try await getAllEvents()        return allEvents.filter { $0.clubId == clubId }    }        func getMyHostedEvents() async throws -> [Event] {        guard let userId = User.current?.objectId else {            return []        }                let query = Event.query()            .order([.descending("createdAt")])                let events = try await query.find()        return events.filter { $0.hostId == userId }    }        func getMyAttendingEvents() async throws -> [Event] {        guard let userId = User.current?.objectId else {            return []        }                // Get all attendee records for this user with "going" status        let allAttendees = try await EventAttendee.query().find()        let myAttendances = allAttendees.filter {             $0.userId == userId && $0.status == AttendeeStatus.going.rawValue         }                let eventIds = myAttendances.compactMap { $0.eventId }                // Get all events        let allEvents = try await Event.query().find()        return allEvents.filter { event in            guard let eventId = event.objectId,                  let eventDate = event.eventDate else { return false }            return eventIds.contains(eventId) && eventDate > Date()        }    }        func searchEvents(query: String) async throws -> [Event] {        let allEvents = try await getAllEvents()                return allEvents.filter { event in            let titleMatch = event.title?.localizedCaseInsensitiveContains(query) ?? false            let descMatch = event.description?.localizedCaseInsensitiveContains(query) ?? false            let tagMatch = event.tags?.contains(where: { $0.localizedCaseInsensitiveContains(query) }) ?? false            return titleMatch || descMatch || tagMatch        }    }            func updateEvent(        eventId: String,        title: String?,        description: String?,        eventDate: Date?,        endDate: Date?,        maxAttendees: Int?    ) async throws {        guard let userId = User.current?.objectId else {            throw NSError(domain: "EventService", code: 401, userInfo: [NSLocalizedDescriptionKey: "User not logged in"])        }                let allEvents = try await Event.query().find()        guard var event = allEvents.first(where: { $0.objectId == eventId }) else {            throw NSError(domain: "EventService", code: 404, userInfo: [NSLocalizedDescriptionKey: "Event not found"])        }                // Check if user is host        guard event.hostId == userId else {            throw NSError(domain: "EventService", code: 403, userInfo: [NSLocalizedDescriptionKey: "Only host can edit event"])        }                if let title = title { event.title = title }        if let description = description { event.description = description }        if let eventDate = eventDate { event.eventDate = eventDate }        if let endDate = endDate { event.endDate = endDate }        if let maxAttendees = maxAttendees { event.maxAttendees = maxAttendees }                _ = try await event.save()        print("✅ Event updated")    }        func deleteEvent(eventId: String) async throws {        guard let userId = User.current?.objectId else {            throw NSError(domain: "EventService", code: 401, userInfo: [NSLocalizedDescriptionKey: "User not logged in"])        }                let allEvents = try await Event.query().find()        guard let event = allEvents.first(where: { $0.objectId == eventId }) else {            throw NSError(domain: "EventService", code: 404, userInfo: [NSLocalizedDescriptionKey: "Event not found"])        }                // Check if user is host        guard event.hostId == userId else {            throw NSError(domain: "EventService", code: 403, userInfo: [NSLocalizedDescriptionKey: "Only host can delete event"])        }                try await event.delete()        print("✅ Event deleted")    }            func respondToEvent(eventId: String, status: AttendeeStatus) async throws {        guard let userId = User.current?.objectId,              let username = User.current?.username else {            throw NSError(domain: "EventService", code: 401, userInfo: [NSLocalizedDescriptionKey: "User not logged in"])        }                // Check if already responded        let allAttendees = try await EventAttendee.query().find()                if let existingAttendee = allAttendees.first(where: {             $0.eventId == eventId && $0.userId == userId         }) {            // Update existing response            var updatedAttendee = existingAttendee            let oldStatus = updatedAttendee.status            updatedAttendee.status = status.rawValue            _ = try await updatedAttendee.save()                        // Update event counts            try await updateEventCounts(eventId: eventId, oldStatus: oldStatus, newStatus: status.rawValue)        } else {            // Create new response            var attendee = EventAttendee()            attendee.eventId = eventId            attendee.userId = userId            attendee.username = username            attendee.status = status.rawValue            attendee.checkedIn = false                        _ = try await attendee.save()                        // Update event counts            try await updateEventCounts(eventId: eventId, oldStatus: nil, newStatus: status.rawValue)        }                print("✅ Event response saved: \(status.rawValue)")    }        func removeEventResponse(eventId: String) async throws {        guard let userId = User.current?.objectId else { return }                let allAttendees = try await EventAttendee.query().find()                if let attendee = allAttendees.first(where: {             $0.eventId == eventId && $0.userId == userId         }) {            let oldStatus = attendee.status            try await attendee.delete()                        // Update event counts            try await updateEventCounts(eventId: eventId, oldStatus: oldStatus, newStatus: nil)        }                print("✅ Event response removed")    }        private func updateEventCounts(eventId: String, oldStatus: String?, newStatus: String?) async throws {        let allEvents = try await Event.query().find()        guard var event = allEvents.first(where: { $0.objectId == eventId }) else { return }                // Decrement old status count        if let oldStatus = oldStatus {            if oldStatus == AttendeeStatus.going.rawValue {                event.attendeesCount = max(0, (event.attendeesCount ?? 1) - 1)            } else if oldStatus == AttendeeStatus.interested.rawValue {                event.interestedCount = max(0, (event.interestedCount ?? 1) - 1)            }        }                // Increment new status count        if let newStatus = newStatus {            if newStatus == AttendeeStatus.going.rawValue {                event.attendeesCount = (event.attendeesCount ?? 0) + 1            } else if newStatus == AttendeeStatus.interested.rawValue {                event.interestedCount = (event.interestedCount ?? 0) + 1            }        }                _ = try await event.save()    }        func getUserEventStatus(eventId: String) async throws -> AttendeeStatus? {        guard let userId = User.current?.objectId else { return nil }                let allAttendees = try await EventAttendee.query().find()                if let attendee = allAttendees.first(where: {             $0.eventId == eventId && $0.userId == userId         }) {            return AttendeeStatus(rawValue: attendee.status ?? "")        }                return nil    }        func getEventAttendees(eventId: String, status: AttendeeStatus? = nil) async throws -> [User] {        let allAttendees = try await EventAttendee.query().find()                var filtered = allAttendees.filter { $0.eventId == eventId }                if let status = status {            filtered = filtered.filter { $0.status == status.rawValue }        }                let userIds = filtered.compactMap { $0.userId }                let allUsers = try await User.query().find()        return allUsers.filter { user in            guard let userId = user.objectId else { return false }            return userIds.contains(userId)        }    }        func checkInToEvent(eventId: String) async throws {        guard let userId = User.current?.objectId else {            throw NSError(domain: "EventService", code: 401, userInfo: [NSLocalizedDescriptionKey: "User not logged in"])        }                let allAttendees = try await EventAttendee.query().find()                guard var attendee = allAttendees.first(where: {             $0.eventId == eventId && $0.userId == userId && $0.status == AttendeeStatus.going.rawValue        }) else {            throw NSError(domain: "EventService", code: 404, userInfo: [NSLocalizedDescriptionKey: "You must RSVP 'going' before checking in"])        }                attendee.checkedIn = true        _ = try await attendee.save()                print("✅ Checked in to event")    }}