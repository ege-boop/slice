////  EventDetailView.swift//  FinalProject////  Complete Event Detail with RSVP//import SwiftUIimport MapKitstruct EventDetailView: View {    let event: Event    @StateObject private var viewModel: EventDetailViewModel    @Environment(\.dismiss) var dismiss    @State private var showAttendees = false    @State private var showEditEvent = false        init(event: Event) {        self.event = event        _viewModel = StateObject(wrappedValue: EventDetailViewModel(event: event))    }        var body: some View {        ScrollView {            VStack(spacing: 0) {                // Header Image                if let imageURL = event.imageURL, let url = URL(string: imageURL) {                    AsyncImage(url: url) { phase in                        switch phase {                        case .success(let image):                            image                                .resizable()                                .scaledToFill()                                .frame(height: 300)                                .clipped()                        case .empty:                            Rectangle()                                .fill(Color.gray.opacity(0.2))                                .frame(height: 300)                                .overlay(ProgressView())                        case .failure:                            Rectangle()                                .fill(LinearGradient(colors: [Color.purple, Color.blue], startPoint: .topLeading, endPoint: .bottomTrailing))                                .frame(height: 300)                        @unknown default:                            EmptyView()                        }                    }                } else {                    Rectangle()                        .fill(LinearGradient(colors: [Color.purple, Color.blue], startPoint: .topLeading, endPoint: .bottomTrailing))                        .frame(height: 300)                        .overlay(                            Image(systemName: "calendar")                                .font(.system(size: 80))                                .foregroundColor(.white)                        )                }                                // Content                VStack(alignment: .leading, spacing: 24) {                    // Title & Host                    VStack(alignment: .leading, spacing: 12) {                        Text(event.title ?? "Event")                            .font(.system(size: 28, weight: .bold))                                                // Host Info                        HStack(spacing: 12) {                            Circle()                                .fill(Color.black)                                .frame(width: 48, height: 48)                                .overlay(                                    Text(event.hostUsername?.prefix(1).uppercased() ?? "?")                                        .font(.system(size: 20, weight: .bold))                                        .foregroundColor(.white)                                )                                                        VStack(alignment: .leading, spacing: 4) {                                Text("Hosted by")                                    .font(.system(size: 13))                                    .foregroundColor(.gray)                                Text("@\(event.hostUsername ?? "user")")                                    .font(.system(size: 16, weight: .semibold))                            }                        }                    }                                        Divider()                                        // Date & Time                    InfoRow(icon: "calendar", title: "When", content: formatEventDateTime())                                        // Location                    if let address = event.address {                        VStack(alignment: .leading, spacing: 12) {                            InfoRow(icon: "mappin.circle.fill", title: "Where", content: address)                                                        // Mini Map                            Map(coordinateRegion: .constant(MKCoordinateRegion(                                center: event.coordinate,                                span: MKCoordinateSpan(latitudeDelta: 0.01, longitudeDelta: 0.01)                            )), annotationItems: [event]) { event in                                MapPin(coordinate: event.coordinate, tint: .red)                            }                            .frame(height: 150)                            .cornerRadius(12)                            .allowsHitTesting(false)                        }                    }                                        // Category                    if let category = event.category {                        InfoRow(icon: "tag.fill", title: "Category", content: category)                    }                                        // Description                    if let description = event.description, !description.isEmpty {                        VStack(alignment: .leading, spacing: 8) {                            Text("About")                                .font(.system(size: 18, weight: .bold))                            Text(description)                                .font(.system(size: 15))                                .foregroundColor(.gray)                        }                    }                                        Divider()                                        // Stats                    HStack(spacing: 40) {                        StatBox(                            icon: "person.2.fill",                            count: event.attendeesCount ?? 0,                            label: "Going"                        )                                                StatBox(                            icon: "star.fill",                            count: event.interestedCount ?? 0,                            label: "Interested"                        )                                                if let maxAttendees = event.maxAttendees {                            StatBox(                                icon: "ticket.fill",                                count: maxAttendees,                                label: "Capacity"                            )                        }                    }                    .padding()                    .background(Color.gray.opacity(0.05))                    .cornerRadius(12)                                        // Attendees Preview                    if !viewModel.attendees.isEmpty {                        VStack(alignment: .leading, spacing: 12) {                            HStack {                                Text("Attendees")                                    .font(.system(size: 18, weight: .bold))                                Spacer()                                Button("View All") {                                    showAttendees = true                                }                                .font(.system(size: 14, weight: .semibold))                                .foregroundColor(.blue)                            }                                                        ScrollView(.horizontal, showsIndicators: false) {                                HStack(spacing: 12) {                                    ForEach(viewModel.attendees.prefix(10), id: \.objectId) { attendee in                                        VStack(spacing: 8) {                                            Circle()                                                .fill(Color.black)                                                .frame(width: 56, height: 56)                                                .overlay(                                                    Text(attendee.username?.prefix(1).uppercased() ?? "?")                                                        .font(.system(size: 22, weight: .bold))                                                        .foregroundColor(.white)                                                )                                                                                        Text(attendee.username ?? "User")                                                .font(.system(size: 12))                                                .lineLimit(1)                                        }                                        .frame(width: 70)                                    }                                }                            }                        }                    }                                        // Tags                    if let tags = event.tags, !tags.isEmpty {                        VStack(alignment: .leading, spacing: 12) {                            Text("Tags")                                .font(.system(size: 18, weight: .bold))                                                        FlowLayout(spacing: 8) {                                ForEach(tags, id: \.self) { tag in                                    Text("#\(tag)")                                        .font(.system(size: 13))                                        .padding(.horizontal, 12)                                        .padding(.vertical, 6)                                        .background(Color.black.opacity(0.05))                                        .cornerRadius(16)                                }                            }                        }                    }                                        // RSVP Buttons                    if !viewModel.isHost {                        VStack(spacing: 12) {                            // Going Button                            Button(action: {                                if viewModel.userStatus == .going {                                    viewModel.removeResponse()                                } else {                                    viewModel.respondToEvent(status: .going)                                }                            }) {                                HStack {                                    Image(systemName: viewModel.userStatus == .going ? "checkmark.circle.fill" : "person.badge.plus")                                    Text(viewModel.userStatus == .going ? "You're Going" : "I'm Going")                                        .font(.system(size: 16, weight: .semibold))                                }                                .foregroundColor(.white)                                .frame(maxWidth: .infinity)                                .padding(.vertical, 16)                                .background(viewModel.userStatus == .going ? Color.green : Color.black)                                .cornerRadius(12)                            }                            .disabled(viewModel.isLoading)                                                        // Interested Button                            Button(action: {                                if viewModel.userStatus == .interested {                                    viewModel.removeResponse()                                } else {                                    viewModel.respondToEvent(status: .interested)                                }                            }) {                                HStack {                                    Image(systemName: viewModel.userStatus == .interested ? "star.fill" : "star")                                    Text(viewModel.userStatus == .interested ? "You're Interested" : "Interested")                                        .font(.system(size: 16, weight: .semibold))                                }                                .foregroundColor(viewModel.userStatus == .interested ? .white : .black)                                .frame(maxWidth: .infinity)                                .padding(.vertical, 16)                                .background(viewModel.userStatus == .interested ? Color.orange : Color.gray.opacity(0.2))                                .cornerRadius(12)                            }                            .disabled(viewModel.isLoading)                        }                    }                }                .padding()            }        }        .navigationBarTitleDisplayMode(.inline)        .toolbar {            if viewModel.isHost {                ToolbarItem(placement: .navigationBarTrailing) {                    Menu {                        Button(action: { showEditEvent = true }) {                            Label("Edit Event", systemImage: "pencil")                        }                                                Button(action: { showAttendees = true }) {                            Label("View Attendees", systemImage: "person.2")                        }                                                Divider()                                                Button(role: .destructive, action: {                            viewModel.deleteEvent {                                dismiss()                            }                        }) {                            Label("Delete Event", systemImage: "trash")                        }                    } label: {                        Image(systemName: "ellipsis.circle")                            .foregroundColor(.black)                    }                }            }        }        .sheet(isPresented: $showAttendees) {            EventAttendeesView(event: event)        }        .onAppear {            viewModel.loadData()        }    }        func formatEventDateTime() -> String {        guard let eventDate = event.eventDate else { return "Date TBD" }                let formatter = DateFormatter()        formatter.dateFormat = "EEEE, MMM d, yyyy 'at' h:mm a"        var result = formatter.string(from: eventDate)                if let endDate = event.endDate {            let endFormatter = DateFormatter()            endFormatter.dateFormat = "h:mm a"            result += " - \(endFormatter.string(from: endDate))"        }                return result    }}struct InfoRow: View {    let icon: String    let title: String    let content: String        var body: some View {        HStack(alignment: .top, spacing: 12) {            Image(systemName: icon)                .font(.system(size: 20))                .foregroundColor(.black)                .frame(width: 24)                        VStack(alignment: .leading, spacing: 4) {                Text(title)                    .font(.system(size: 13))                    .foregroundColor(.gray)                Text(content)                    .font(.system(size: 15))                    .foregroundColor(.black)            }                        Spacer()        }    }}struct StatBox: View {    let icon: String    let count: Int    let label: String        var body: some View {        VStack(spacing: 8) {            Image(systemName: icon)                .font(.system(size: 24))                .foregroundColor(.black)            Text("\(count)")                .font(.system(size: 20, weight: .bold))            Text(label)                .font(.system(size: 12))                .foregroundColor(.gray)        }        .frame(maxWidth: .infinity)    }}// Simple Flow Layout for tagsstruct FlowLayout: Layout {    var spacing: CGFloat = 8        func sizeThatFits(proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) -> CGSize {        let result = FlowResult(in: proposal.replacingUnspecifiedDimensions().width, subviews: subviews, spacing: spacing)        return result.size    }        func placeSubviews(in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) {        let result = FlowResult(in: bounds.width, subviews: subviews, spacing: spacing)        for (index, subview) in subviews.enumerated() {            subview.place(at: CGPoint(x: bounds.minX + result.positions[index].x, y: bounds.minY + result.positions[index].y), proposal: .unspecified)        }    }        struct FlowResult {        var size: CGSize = .zero        var positions: [CGPoint] = []                init(in maxWidth: CGFloat, subviews: Subviews, spacing: CGFloat) {            var x: CGFloat = 0            var y: CGFloat = 0            var lineHeight: CGFloat = 0                        for subview in subviews {                let size = subview.sizeThatFits(.unspecified)                                if x + size.width > maxWidth && x > 0 {                    x = 0                    y += lineHeight + spacing                    lineHeight = 0                }                                positions.append(CGPoint(x: x, y: y))                lineHeight = max(lineHeight, size.height)                x += size.width + spacing            }                        self.size = CGSize(width: maxWidth, height: y + lineHeight)        }    }}class EventDetailViewModel: ObservableObject {    let event: Event    @Published var attendees: [User] = []    @Published var userStatus: AttendeeStatus?    @Published var isHost = false    @Published var isLoading = false        init(event: Event) {        self.event = event        checkIfHost()    }        func loadData() {        loadAttendees()        loadUserStatus()    }        func checkIfHost() {        isHost = event.hostId == User.current?.objectId    }        func loadAttendees() {        guard let eventId = event.objectId else { return }                Task {            do {                let going = try await EventService.shared.getEventAttendees(eventId: eventId, status: .going)                await MainActor.run {                    self.attendees = going                }            } catch {                print("Error loading attendees: \(error)")            }        }    }        func loadUserStatus() {        guard let eventId = event.objectId else { return }                Task {            do {                let status = try await EventService.shared.getUserEventStatus(eventId: eventId)                await MainActor.run {                    self.userStatus = status                }            } catch {                print("Error loading user status: \(error)")            }        }    }        func respondToEvent(status: AttendeeStatus) {        guard let eventId = event.objectId else { return }                isLoading = true                Task {            do {                try await EventService.shared.respondToEvent(eventId: eventId, status: status)                await MainActor.run {                    self.userStatus = status                    self.isLoading = false                    self.loadAttendees()                }            } catch {                await MainActor.run {                    self.isLoading = false                    print("Error responding to event: \(error)")                }            }        }    }        func removeResponse() {        guard let eventId = event.objectId else { return }                isLoading = true                Task {            do {                try await EventService.shared.removeEventResponse(eventId: eventId)                await MainActor.run {                    self.userStatus = nil                    self.isLoading = false                    self.loadAttendees()                }            } catch {                await MainActor.run {                    self.isLoading = false                    print("Error removing response: \(error)")                }            }        }    }        func deleteEvent(completion: @escaping () -> Void) {        guard let eventId = event.objectId else { return }                Task {            do {                try await EventService.shared.deleteEvent(eventId: eventId)                await MainActor.run {                    completion()                }            } catch {                print("Error deleting event: \(error)")            }        }    }}// Make Event identifiable for Mapextension Event: Identifiable {    var id: String? { objectId }}#Preview {    NavigationView {        EventDetailView(event: Event())    }}