import Foundationimport CoreLocationimport MapKitclass TicketmasterService {    static let shared = TicketmasterService()        private let apiKey = "2GUPwo7Hz7wvdldiXPnQSHGAGfnpZLfG"    private let baseURL = "https://app.ticketmaster.com/discovery/v2"        private init() {}        // NEW: Fetch events worldwide (no location filter)    func fetchEventsWorldwide() async throws -> [TMEventModel] {        let urlString = "\(baseURL)/events.json?apikey=\(apiKey)&sort=date,asc&size=200&countryCode=US,CA,GB,AU,MX,FR,DE,ES,IT,NL"                print("ğŸŒ Fetching worldwide events")                guard let url = URL(string: urlString) else {            throw URLError(.badURL)        }                let (data, _) = try await URLSession.shared.data(from: url)        let response = try JSONDecoder().decode(TMAPIResponse.self, from: data)                let events = response._embedded?.events ?? []        print("âœ… Found \(events.count) worldwide events")                return events    }        func fetchEvents(near location: CLLocationCoordinate2D, radius: Int = 50) async throws -> [TMEventModel] {        let urlString = "\(baseURL)/events.json?apikey=\(apiKey)&latlong=\(location.latitude),\(location.longitude)&radius=\(radius)&unit=miles&sort=date,asc&size=50"                print("ğŸŒ Fetching events near location")                guard let url = URL(string: urlString) else {            throw URLError(.badURL)        }                let (data, _) = try await URLSession.shared.data(from: url)        let response = try JSONDecoder().decode(TMAPIResponse.self, from: data)                let events = response._embedded?.events ?? []        print("âœ… Found \(events.count) events")                return events    }        func searchEvents(keyword: String) async throws -> [TMEventModel] {        let urlString = "\(baseURL)/events.json?apikey=\(apiKey)&keyword=\(keyword)&sort=date,asc&size=200"                guard let url = URL(string: urlString.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? "") else {            throw URLError(.badURL)        }                let (data, _) = try await URLSession.shared.data(from: url)        let response = try JSONDecoder().decode(TMAPIResponse.self, from: data)                return response._embedded?.events ?? []    }        func fetchEventsByCategory(category: String) async throws -> [TMEventModel] {        let urlString = "\(baseURL)/events.json?apikey=\(apiKey)&classificationName=\(category)&sort=date,asc&size=200&countryCode=US,CA,GB,AU,MX,FR,DE,ES,IT,NL"                guard let url = URL(string: urlString.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? "") else {            throw URLError(.badURL)        }                let (data, _) = try await URLSession.shared.data(from: url)        let response = try JSONDecoder().decode(TMAPIResponse.self, from: data)                return response._embedded?.events ?? []    }}struct TMAPIResponse: Codable {    let _embedded: TMEmbeddedData?}struct TMEmbeddedData: Codable {    let events: [TMEventModel]?}struct TMEventModel: Codable, Identifiable {    let id: String    let name: String    let url: String?    let images: [TMEventImage]?    let dates: TMEventDates?    let priceRanges: [TMPriceRange]?    let classifications: [TMClassification]?    let _embedded: TMEventEmbeddedData?        var imageURL: String? {        let sortedImages = images?.sorted { ($0.width ?? 0) > ($1.width ?? 0) }        return sortedImages?.first?.url    }        var dateString: String {        guard let startDate = dates?.start?.localDate else { return "Date TBA" }        let formatter = DateFormatter()        formatter.dateFormat = "yyyy-MM-dd"        if let date = formatter.date(from: startDate) {            formatter.dateStyle = .long            return formatter.string(from: date)        }        return startDate    }        var timeString: String? {        guard let time = dates?.start?.localTime else { return nil }        let formatter = DateFormatter()        formatter.dateFormat = "HH:mm:ss"        if let date = formatter.date(from: time) {            formatter.dateFormat = "h:mm a"            return formatter.string(from: date)        }        return time    }        var venueName: String {        _embedded?.venues?.first?.name ?? "Venue TBA"    }        var venueCity: String {        _embedded?.venues?.first?.city?.name ?? ""    }        var coordinate: CLLocationCoordinate2D {        guard let venue = _embedded?.venues?.first,              let latString = venue.location?.latitude,              let lonString = venue.location?.longitude,              let lat = Double(latString),              let lon = Double(lonString) else {            return CLLocationCoordinate2D(latitude: 37.7749, longitude: -122.4194)        }        return CLLocationCoordinate2D(latitude: lat, longitude: lon)    }        var hasValidCoordinates: Bool {        guard let venue = _embedded?.venues?.first,              let latString = venue.location?.latitude,              let lonString = venue.location?.longitude,              Double(latString) != nil,              Double(lonString) != nil else {            return false        }        return true    }        var priceRange: String? {        guard let prices = priceRanges, !prices.isEmpty else {            return nil        }                let price = prices.first!                if let min = price.min, let max = price.max {            return "$\(Int(min)) - $\(Int(max))"        } else if let min = price.min {            return "From $\(Int(min))"        }                return nil    }        var categoryName: String? {        classifications?.first?.segment?.name    }}struct TMEventImage: Codable {    let url: String?    let width: Int?    let height: Int?}struct TMEventDates: Codable {    let start: TMEventStart?}struct TMEventStart: Codable {    let localDate: String?    let localTime: String?}struct TMPriceRange: Codable {    let min: Double?    let max: Double?    let currency: String?}struct TMClassification: Codable {    let segment: TMSegment?    let genre: TMGenre?}struct TMSegment: Codable {    let name: String?}struct TMGenre: Codable {    let name: String?}struct TMEventEmbeddedData: Codable {    let venues: [TMEventVenue]?}struct TMEventVenue: Codable {    let name: String?    let city: TMEventCity?    let location: TMEventLocation?}struct TMEventCity: Codable {    let name: String?}struct TMEventLocation: Codable {    let latitude: String?    let longitude: String?}extension TMEventModel: Equatable {    static func == (lhs: TMEventModel, rhs: TMEventModel) -> Bool {        lhs.id == rhs.id    }}